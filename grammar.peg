start
  = pipelines

// @ parser
// ~~~~~~~~

letter = [a-zA-Z0-9_-]
space = [ \n\t\r]*
comma = space "," space
dot = space "." space { return 'get'; }
col = space ":" space { return 'map'; }
open_bracket = space "[" space
close_bracket = space "]" space
at = space "@" space

word = ls:letter+ { return ls.join(''); }

array = open_bracket
    values:(
        head:at_expression
        tail:(comma t:at_expression { return t; })*
        { return [head].concat(tail); }
    )
    close_bracket { return values; }

okv =
    k:word col v:at_expression { return {key: k, val: v}; }
    / k:sub_cmd col v:at_expression { return {key: [k], val: v}; }
    / k:word { return {key: k, val: [{get: k}]}; }

obj = "{" space ss:(okv comma?)+ space "}" {
    ss = ss.map(function(sp) { return sp[0]; });
    return {obj: ss};
}

section = obj / array / word

do_sub = (s:dot t:sub_cmd { return t; })
do_sub_ = (s:dot? t:sub_cmd { return t; })
do_get = (s:dot t:section { return {get: t}; })
do_get_ = (s:dot? t:section { return {get: t}; }) / (s:dot { return {get: '.'}; })
do_map = (s:col+ t:section { return {map: t, depth:s.length}; })
do_section = do_get / do_map

at_expression =
    space
    head:(do_get_/do_sub_/do_map)
    tail:do_section*
    space
    {
        return [head].concat(tail);
    }

// Pipeline parser
// ~~~~~~~~~~~~~~~

pipe = space "|" space
ppipe = space "||" space
spipe = space "|=" space
quote = space ["'] space
quote_ = space ["']
_quote = ["'] space

number = s:"-"? ds:[0-9]+ { n = Number(ds.join('')); if (s) n = n*-1; return n; }
ok_char = letter / [=:/.,#%!?'+*%^&{}\[\]]
escd_at = (letter "@" cmd_char / "\\@") { return "@"; }
escd_paren = "\\(" { return "("; } / "\\)" { return ")"; }
letter_word = ls:letter+ { return ls.join(''); }
var_word = "$" w:letter_word { return '$' + w; }
    / "$!"
cmd_char = ok_char / escd_at / escd_paren / var_word
cmd_word = cs:cmd_char+ { return cs.join('').trim(); }
quoted_cmd = quote cmd:cmd quote { return {quoted: cmd}; }
quoted_literal = quote_ ls:(" " / cmd_char / "\\n" { return '\n'; })* _quote { return {quoted: [ls.join('')] }; }
quoted_phrase = quoted_literal / quoted_cmd
cmd_phrase = quoted_phrase / cmd_word / sub_cmd 

cmd = head:cmd_phrase
      tail:(space c:cmd_phrase { return c; })*
      { return [head].concat(tail); }

cmd_at = 
    cmd:cmd
    atexp:(at atexp:at_expression { return atexp; })?
    { return {cmd: cmd, at: atexp}; }

var_exp =
    var_word:var_word
    atexp:(at atexp:at_expression { return atexp; })?
    { return {var: var_word, at: atexp}; }

start_cmd =
    var_exp
    / number:number { return {val: number}; }
    / quoted:quoted_phrase { return {val: quoted}; }
    / cmd_at:cmd_at { cmd_at.type = 'pipe'; return cmd_at; }
piped_cmd =
    pipe cmd_at:cmd_at
    { cmd_at.type = 'pipe'; return cmd_at; }
ppiped_cmd =
    ppipe cmd_at:cmd_at
    { cmd_at.type = 'ppipe'; return cmd_at; }
spiped_cmd =
    spipe cmd_at:cmd_at
    { cmd_at.type = 'spipe'; return cmd_at; }

cmd_section = at at_expression / start_cmd / ppiped_cmd / spiped_cmd / piped_cmd 

sub_cmd =
    "$("
    pipelines:pipelines
    ")"
    {
        return {sub:pipelines};
    }

pipeline =
    space
    head:(at atexp:at_expression { return {at: atexp}; })?
    tail:cmd_section*
    space
    { if (head) return [head].concat(tail); else return tail; }

semi = space ";" space
pipelines =
    head:(aliasing / setting / pipeline)
    tail:(semi pipeline:pipeline { return pipeline; })*
    { return [head].concat(tail); }

setup = var_word:letter_word space "=" space { return var_word; }

aliasing =
    space "alias" space alias:letter_word space "=" space rest:.+
    { return [{cmd: ['alias', alias, rest.join('').trim()]}]; }

setting =
    space set:setup pipeline:pipeline
    { return [{cmd: ['let', set, {sub: [pipeline]}]}]; }


// Generated by CoffeeScript 1.11.1
(function() {
  var Pipeline, PipelineREPL, _, ansi, argv, builtins, colorize, defaultPipeline, doRunScript, fs, getHomeDir, history_path, loadHistory, moment, path, piped, prettyPrint, readline, readline_vim, repl, saveHistory, script, script_filename,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  readline = require('readline');

  readline_vim = require('readline-vim');

  Pipeline = require('./pipeline').Pipeline;

  moment = require('moment');

  builtins = require('./builtins');

  ansi = require('ansi')(process.stdout);

  prettyPrint = require('./helpers').prettyPrint;

  fs = require('fs');

  path = require('path');

  _ = require('underscore');

  argv = require('yargs').argv;

  getHomeDir = function() {
    return process.env.HOME || process.env.HOMEPATH || process.env.USERPROFILE;
  };

  process.on('SIGTERM', function() {
    console.log('sigterm');
    return process.exit();
  });

  process.on('SIGINT', function() {
    console.log('sigint');
    return process.exit();
  });

  PipelineREPL = function(pipeline) {
    var base_env;
    this.pipeline = pipeline;
    if (!this.pipeline) {
      this.pipeline = defaultPipeline();
    }
    this.context = this.pipeline.subScope();
    base_env = _.omit(argv, '_');
    _.forEach(base_env, (function(_this) {
      return function(v, k) {
        return _this.context.set('vars', k, v);
      };
    })(this));
    this.last_out = null;
    return this;
  };

  defaultPipeline = function() {
    return new Pipeline().use('http').use('html').use('files').use('keywords');
  };

  PipelineREPL.prototype.writeSuccess = function(data) {
    if (data != null) {
      if (this.plain) {
        return console.log(data);
      } else {
        return console.log(prettyPrint(data));
      }
    }
  };

  PipelineREPL.prototype.writeError = function(err) {
    ansi.fg['red']();
    console.log('[ERROR] ' + err);
    return ansi.reset();
  };

  PipelineREPL.prototype.executeScript = function(script, cb) {
    var e;
    try {
      return this.pipeline.exec(script, this.last_out, this.context, (function(_this) {
        return function(err, data) {
          _this.last_out = data;
          if (err != null) {
            _this.writeError(err);
          } else {
            _this.writeSuccess(data);
          }
          if (cb != null) {
            return cb();
          }
        };
      })(this));
    } catch (error) {
      e = error;
      this.writeError(e);
      if (cb != null) {
        return cb();
      }
    }
  };

  PipelineREPL.prototype.startReadline = function() {
    var f, fnCompleter, fn_names, n, repl, rl, rl_addHistory, rlv, run_once;
    repl = this;
    fn_names = ((function() {
      var ref, results;
      ref = repl.pipeline.fns;
      results = [];
      for (n in ref) {
        f = ref[n];
        results.push(n);
      }
      return results;
    })()).concat((function() {
      var results;
      results = [];
      for (n in builtins) {
        f = builtins[n];
        results.push(n);
      }
      return results;
    })());
    fnCompleter = function(line) {
      var base_dir, completions, file_commands, last_part, line_parts, ref, startsWith, to_complete;
      line_parts = line.trim().split(/\s+/);
      to_complete = line_parts.slice(-1)[0];
      startsWith = function(sofar) {
        return function(s) {
          return s.toLowerCase().indexOf(sofar.toLowerCase()) === 0;
        };
      };
      file_commands = ['ls', 'cp', 'mv', 'ln', 'cd', 'cat', 'vim', 'coffee', 'python', 'git', 'open'];
      if (to_complete.match('/')) {
        base_dir = to_complete.split('/').slice(0, -1).join('/');
        last_part = to_complete.split('/').slice(-1)[0];
        to_complete = last_part;
        completions = fs.readdirSync(base_dir).filter(startsWith(last_part));
      } else {
        completions = fs.readdirSync('.').filter(startsWith(to_complete));
      }
      if (ref = line_parts[0], indexOf.call(file_commands, ref) < 0) {
        completions = completions.concat(fn_names.filter(startsWith(to_complete)));
      }
      return [completions, to_complete];
    };
    rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout,
      completer: fnCompleter
    });
    rlv = readline_vim(rl);
    this.rl = rl;
    this.context._readline = rl;
    rl_addHistory = rl._addHistory;
    rl._addHistory = function() {
      var last, line;
      last = rl.history[0];
      line = rl_addHistory.call(rl);
      if (last !== line) {
        saveHistory(line);
      }
      return line;
    };
    loadHistory(function(err, saved_history) {
      return rl.history.push.apply(rl.history, saved_history);
    });
    this.updatePrompt();
    rl.prompt();
    run_once = this.run_once || !process.stdin.isTTY;
    rl.on('line', (function(_this) {
      return function(script) {
        script = script.trim();
        if (!script.length) {
          script = 'id';
        }
        return repl.executeScript(script, function() {
          var script_exec;
          if (run_once) {
            if (script_exec = argv.exec || argv.e) {
              return repl.executeScript(script_exec, function() {
                return process.exit();
              });
            } else {
              return process.exit();
            }
          } else {
            _this.updatePrompt();
            return rl.prompt();
          }
        });
      };
    })(this));
    return rl.on('close', function() {
      console.log('bye');
      return process.exit();
    });
  };

  colorize = function(s, color) {
    var prefix, suffix;
    prefix = '\x1b[' + color + 'm';
    suffix = '\x1b[0m';
    return prefix + s + suffix;
  };

  PipelineREPL.prototype.updatePrompt = function() {
    var cwd, parts, time;
    time = '[' + moment().format('HH:mm') + ']';
    cwd = process.cwd().replace(process.env.HOME, '~');
    parts = [colorize(time, 90), colorize(cwd, 34), colorize('#| ', 36)].join(' ');
    return this.rl.setPrompt(parts);
  };

  history_path = path.resolve(getHomeDir(), '.pipeline_history');

  saveHistory = function(line) {
    return fs.appendFile(history_path, line + '\n');
  };

  loadHistory = function(cb) {
    return fs.readFile(history_path, function(err, history_data) {
      var history_lines;
      if (!history_data) {
        return cb(null, []);
      }
      history_lines = history_data.toString().trim().split('\n');
      history_lines.reverse();
      return cb(null, history_lines);
    });
  };

  if (require.main !== module) {
    module.exports = PipelineREPL;
  } else {
    repl = new PipelineREPL;
    if (argv.plain || argv.p) {
      repl.plain = true;
    }
    if (script_filename = argv.run || argv.r) {
      doRunScript = function() {
        var script;
        script = fs.readFileSync(script_filename).toString();
        return setTimeout(function() {
          return repl.executeScript(script, function() {
            return process.exit();
          });
        }, 50);
      };
      if (!process.stdin.isTTY) {
        piped = '';
        process.stdin.on('data', function(data) {
          return piped += data.toString();
        });
        process.stdin.on('end', function() {
          repl.last_out = piped.trim();
          return doRunScript();
        });
      } else {
        doRunScript();
      }
    } else if (script_filename = argv.load || argv.l) {
      console.log("Reading from " + script_filename + "...");
      script = fs.readFileSync(script_filename).toString();
      setTimeout(function() {
        return repl.executeScript(script, function() {
          return repl.startReadline();
        });
      }, 50);
    } else {
      repl.startReadline();
    }
  }

}).call(this);

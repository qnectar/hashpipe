// Generated by CoffeeScript 1.8.0
(function() {
  var cachedGetJson, chunk_length, consumer_key, default_args, default_limit, default_limit_per, dolog, feedFetchStream, fetchStream, getFavorites, getFollowings, getResource, getSongFavoriters, getTrack, getTracks, getUser, h, log, mapobjwith, qs, redis, request, resolve, resolveOne, searchTracks, searchUsers, shuffle, somata, util, wrapCallback, wrapStream, _,
    __slice = [].slice;

  request = require('request');

  qs = require('querystring');

  h = require('highland');

  somata = require('somata');

  log = somata.helpers.log;

  util = require('util');

  redis = require('redis').createClient();

  _ = require('underscore');

  dolog = h.curry(function(t, s) {
    return log(("[" + t + "] ") + util.inspect(s).slice(0, 81).replace(/\s+/g, ' '));
  });

  shuffle = function(a) {
    var i, j, _i, _ref, _ref1;
    for (i = _i = _ref = a.length - 1; _ref <= 1 ? _i <= 1 : _i >= 1; i = _ref <= 1 ? ++_i : --_i) {
      j = Math.floor(Math.random() * (i + 1));
      _ref1 = [a[j], a[i]], a[i] = _ref1[0], a[j] = _ref1[1];
    }
    return a;
  };

  consumer_key = "fc17d182cbdc4625d5a0b62322763759";

  default_args = {
    consumer_key: consumer_key,
    json: true
  };

  default_limit = 50;

  default_limit_per = 50;

  chunk_length = 50;

  cachedGetJson = function(options, cb) {
    var cache_key;
    cache_key = 'cached:' + options.url;
    return redis.exists(cache_key, function(err, exists) {
      if (exists) {
        return redis.get(cache_key, function(err, cached_string) {
          var cached;
          cached = JSON.parse(cached_string);
          return cb(null, cached);
        });
      } else {
        return request.get(options, function(err, res, data_string) {
          var data;
          redis.set(cache_key, data_string);
          data = JSON.parse(data_string);
          return cb(null, data);
        });
      }
    });
  };

  fetchStream = function(path, args, limit) {
    var stream;
    if (limit == null) {
      limit = default_limit;
    }
    stream = h();
    feedFetchStream(stream, path, args, limit);
    return stream.flatten().take(limit);
  };

  feedFetchStream = function(stream, path, args, limit, offset) {
    var query_args, query_string, req_options, url;
    if (limit == null) {
      limit = default_limit;
    }
    if (offset == null) {
      offset = 0;
    }
    query_args = h.extend(default_args, {
      offset: offset,
      limit: default_limit_per
    });
    if (args != null) {
      query_args = h.extend(args, query_args);
    }
    query_string = qs.stringify(query_args);
    url = "http://api.soundcloud.com/" + path + ".json?" + query_string;
    req_options = {
      url: url
    };
    log("[fetch] " + path);
    cachedGetJson(req_options, function(err, data) {
      stream.write(data);
      if ((data.length === chunk_length) && (offset + chunk_length < limit)) {
        return feedFetchStream(stream, path, args, limit, offset + chunk_length);
      } else {
        return stream.end();
      }
    });
    return stream;
  };

  resolve = function(url) {
    if (url.match(/http.*soundcloud\.com/) == null) {
      url = "http://soundcloud.com/" + url;
    }
    return fetchStream("resolve", {
      url: url
    });
  };

  resolveOne = function(url, cb) {
    return resolve(url).take(1).toArray(function(_arg) {
      var i;
      i = _arg[0];
      return cb(null, i);
    });
  };

  getResource = function(path) {
    return fetchStream(path);
  };

  getTrack = function(track) {
    return fetchStream("tracks/" + track.id);
  };

  getUser = function(user) {
    return fetchStream("users/" + user.id);
  };

  getFollowings = function(user, limit) {
    if (limit == null) {
      limit = 10;
    }
    return fetchStream("users/" + user.id + "/followings", null, limit);
  };

  getTracks = function(user, limit) {
    if (limit == null) {
      limit = 50;
    }
    return fetchStream("users/" + user.id + "/tracks", null, limit);
  };

  getFavorites = function(user, limit) {
    if (limit == null) {
      limit = 50;
    }
    return fetchStream("users/" + user.id + "/favorites", null, limit);
  };

  getSongFavoriters = function(song, limit) {
    if (limit == null) {
      limit = 50;
    }
    return fetchStream("tracks/" + song.id + "/favoriters", null, limit);
  };

  searchTracks = function(query, limit) {
    if (limit == null) {
      limit = 50;
    }
    return fetchStream("tracks", {
      q: query
    }, limit);
  };

  searchUsers = function(query, limit) {
    if (limit == null) {
      limit = 50;
    }
    return fetchStream("users", {
      q: query
    }, limit);
  };

  wrapStream = function(method) {
    return function(inp, args, ctx, cb) {
      return method.apply(null, args).toArray(function(got) {
        return cb(null, got);
      });
    };
  };

  wrapCallback = function(method) {
    return function(inp, args, ctx, cb) {
      return method.apply(null, __slice.call(args).concat([cb]));
    };
  };

  mapobjwith = function(f) {
    return function(o) {
      return _.object(_.pairs(o).map(function(_arg) {
        var k, v;
        k = _arg[0], v = _arg[1];
        return [k, f(v)];
      }));
    };
  };

  module.exports = _.extend({}, mapobjwith(wrapStream)({
    resolve: resolve,
    getResource: getResource,
    getTrack: getTrack,
    getUser: getUser,
    getFollowings: getFollowings,
    getTracks: getTracks,
    getFavorites: getFavorites,
    getSongFavoriters: getSongFavoriters,
    searchTracks: searchTracks,
    searchUsers: searchUsers
  }), mapobjwith(wrapCallback)({
    resolveOne: resolveOne
  }));

  console.log(util.inspect(module.exports));

}).call(this);

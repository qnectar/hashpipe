// Generated by CoffeeScript 1.11.1
(function() {
  var Context, DEBUG, Pipeline, Scope, _, _inspect, accessor, async, at, builtins, descendObj, doCmd, fs, grammar, inspect, mapInto, parsePipelines, recv_, runPipeline, runPipelines, splitArgs, through, util,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  grammar = require('./grammar');

  builtins = require('./builtins');

  async = require('async');

  fs = require('fs');

  util = require('util');

  _ = require('underscore');

  DEBUG = false;

  recv_ = function(t, s) {
    return console.log("[" + (t.toUpperCase()) + "] " + s);
  };

  _inspect = function(o) {
    return util.inspect(o, {
      depth: null
    });
  };

  inspect = function(o) {
    return console.log(_inspect(o));
  };

  Scope = (function() {
    function Scope(init) {
      if (init == null) {
        init = {};
      }
      _.extend(this, init);
      return this;
    }

    Scope.prototype.set = function(t, k, v) {
      if (DEBUG) {
        console.log("[Scope set] Setting " + t + " " + k + " to " + v);
      }
      if (this[t] == null) {
        this[t] = {};
      }
      this[t][k] = v;
      return this;
    };

    Scope.prototype.get = function(t, k) {
      var got, ref, ref1;
      if (DEBUG) {
        console.log("[Scope get] Getting " + t + " " + k);
      }
      if (k != null) {
        got = (ref = this[t]) != null ? ref[k] : void 0;
      }
      if (k == null) {
        got = this[t];
      }
      return got || ((ref1 = this.parent) != null ? ref1.get(t, k) : void 0);
    };

    Scope.prototype.alias = function(a, s) {
      if (this.parent != null) {
        return this.parent.alias(a, s);
      } else {
        this.set('fns', a, through(s));
        return this.set('aliases', a, s);
      }
    };

    Scope.prototype.subScope = function(init) {
      if (init == null) {
        init = {};
      }
      init.parent = this;
      return new Scope(init);
    };

    Scope.prototype.topScope = function() {
      if (this.parent != null) {
        return this.parent.topScope();
      } else {
        return this;
      }
    };

    return Scope;

  })();

  Context = (function(superClass) {
    extend(Context, superClass);

    function Context() {
      return Context.__super__.constructor.apply(this, arguments);
    }

    return Context;

  })(Scope);

  Pipeline = (function(superClass) {
    extend(Pipeline, superClass);

    function Pipeline() {
      return Pipeline.__super__.constructor.apply(this, arguments);
    }

    Pipeline.prototype.use = function(fns) {
      var k, ref, v;
      if (_.isString(fns)) {
        if (fns.match(/^\w/)) {
          fns = './modules/' + fns;
        }
        ref = require(fns);
        for (k in ref) {
          v = ref[k];
          this.set('fns', k, v);
        }
      } else if (_.isObject(fns)) {
        for (k in fns) {
          v = fns[k];
          this.set('fns', k, v);
        }
      }
      return this;
    };

    Pipeline.prototype.exec = function(script, inp, ctx, cb) {
      var e, pipelines;
      if (cb == null) {
        cb = ctx;
        ctx = this.subScope();
      }
      if (cb == null) {
        cb = inp;
        inp = null;
      }
      try {
        pipelines = parsePipelines(script);
      } catch (error) {
        e = error;
        cb("Error parsing pipeline: " + e);
      }
      try {
        runPipelines(pipelines, inp, ctx, cb);
      } catch (error) {
        e = error;
        cb("Error executing pipeline: " + e);
      }
      return ctx;
    };

    Pipeline.prototype.execFile = function(script_filename, inp, ctx, cb) {
      var script;
      script = fs.readFileSync(script_filename).toString();
      return this.exec(script, inp, ctx, cb);
    };

    return Pipeline;

  })(Scope);

  parsePipelines = function(cmd) {
    return grammar.parse(cmd);
  };

  runPipelines = function(pipelines, inp, ctx, cb) {
    var _runPipeline;
    if (pipelines.length > 1) {
      _runPipeline = function(_pipeline, _cb) {
        return runPipeline(_pipeline, inp, ctx, _cb);
      };
      return async.mapSeries(pipelines, _runPipeline, function(err, results) {
        return cb(err, results.slice(-1)[0]);
      });
    } else {
      return runPipeline(pipelines[0], inp, ctx, cb);
    }
  };

  runPipeline = function(_cmd_tokens, inp, ctx, final_cb) {
    var $key, applyAt, cb, cmd_args, cmd_token, cmd_tokens, cmd_type, key, parseArgs, tasks, val;
    if (DEBUG) {
      console.log('\n=== RUNNING PIPELINE ===');
      inspect(inp);
      console.log(' ---> ');
      inspect(_cmd_tokens);
      console.log('========================\n');
    }
    cmd_tokens = _.clone(_cmd_tokens);
    cmd_token = cmd_tokens.shift();
    cmd_args = cmd_token.cmd;
    cmd_type = cmd_token.type;
    if (!cmd_args) {
      cmd_args = ['id'];
    }
    parseArgs = function(inp, args, cb) {
      var replaceArg;
      if (DEBUG) {
        console.log('parsing args for ' + _inspect(inp));
        console.log(':::> ' + _inspect(args));
      }
      if (cmd_args[0] === 'alias') {
        return cb(null, args);
      }
      replaceArg = function(arg, _cb) {
        var $key, key, val;
        if (_.isObject(arg)) {
          if (arg.sub != null) {
            return runPipelines(arg.sub, inp, ctx, _cb);
          } else if (arg.quoted != null) {
            return parseArgs(inp, arg.quoted, function(err, qargs) {
              return _cb(null, qargs.join(' '));
            });
          }
        } else if (_.isString(arg)) {
          if ($key = arg.match(/^-?[0-9]+$/)) {
            arg = parseInt(arg);
          } else if ($key = arg.match(/\\\$[a-zA-Z0-9_-]*$/)) {
            arg = $key[0].slice(1);
          } else {
            while ($key = arg.match(/\$[!a-zA-Z0-9_-]+/)) {
              $key = $key[0];
              if ($key === '$!') {
                val = inp;
              } else {
                key = $key.slice(1);
                val = ctx.get('vars', key);
              }
              arg = arg.replace($key, val);
            }
          }
        }
        return _cb(null, arg);
      };
      return async.map(args, replaceArg, function(err, new_args) {
        return cb(null, new_args);
      });
    };
    applyAt = function(data, cb) {
      var _at;
      if (cmd_token.at != null) {
        if (cmd_type === 'ppipe' || cmd_type === 'spipe') {
          _at = function(_data, _cb) {
            return at(_data, cmd_token.at, ctx, _cb);
          };
          return async.map(data, _at, cb);
        } else {
          return at(data, cmd_token.at, ctx, cb);
        }
      } else {
        return cb(null, data);
      }
    };
    if (cmd_tokens.length === 0) {
      cb = function(err, ret) {
        if (DEBUG) {
          console.log(' ===> ' + _inspect(ret));
        }
        if (err) {
          return final_cb(err);
        } else {
          return applyAt(ret, final_cb);
        }
      };
    } else {
      cb = function(err, ret) {
        return applyAt(ret, function(err, ret) {
          return runPipeline(cmd_tokens, ret, ctx, final_cb);
        });
      };
    }
    if (cmd_type === 'ppipe') {
      if (DEBUG) {
        console.log('PPIPE: ' + _inspect(cmd_args));
      }
      tasks = inp.map(function(_inp) {
        return function(_cb) {
          return parseArgs(_inp, cmd_args, function(err, args) {
            return doCmd(args, _inp, ctx, _cb);
          });
        };
      });
      return async.parallel(tasks, cb);
    } else if (cmd_type === 'spipe') {
      if (DEBUG) {
        console.log('SPIPE: ' + _inspect(cmd_args));
      }
      tasks = inp.map(function(_inp) {
        return function(_cb) {
          return parseArgs(_inp, cmd_args, function(err, args) {
            return doCmd(args, _inp, ctx, _cb);
          });
        };
      });
      return async.series(tasks, cb);
    } else if (cmd_token.val != null) {
      if (DEBUG) {
        console.log('VAL: ' + _inspect(cmd_args));
      }
      return parseArgs(inp, [cmd_token.val], function(err, parsed) {
        return cb(null, parsed[0]);
      });
    } else if (cmd_token["var"] != null) {
      if (DEBUG) {
        console.log('VAR: ' + _inspect(cmd_args));
      }
      $key = cmd_token["var"];
      if ($key === '$!') {
        val = inp;
      } else {
        key = $key.slice(1);
        val = ctx.get('vars', key);
      }
      return cb(null, val);
    } else {
      if (DEBUG) {
        console.log('PIPE: ' + _inspect(cmd_args));
      }
      return parseArgs(inp, cmd_args, function(err, args) {
        return doCmd(args, inp, ctx, cb);
      });
    }
  };

  doCmd = function(_args, inp, ctx, cb) {
    var args, cmd, fn;
    if (DEBUG) {
      console.log('\n##### DO CMD ######');
      inspect(_args);
      inspect(inp);
      console.log('###################\n');
    }
    args = _.clone(_args);
    cmd = args.shift();
    if (fn = builtins[cmd]) {
      return fn(inp, args, ctx, cb);
    } else if (fn = ctx.get('fns', cmd)) {
      return fn(inp, args, ctx, cb);
    } else {
      return cb("No command " + cmd + ". ");
    }
  };

  splitArgs = function(s) {
    var args;
    args = [];
    s.trim().replace(/"([^"]*)"|'([^']*)'|(\S+)/g, function(g0, g1, g2, g3) {
      return args.push(g1 || g2 || g3 || '');
    });
    return args;
  };

  mapInto = function(l, f, d, cb) {
    var _into;
    if (d === 1) {
      return async.map(l, f, cb);
    } else {
      _into = function(_l, _cb) {
        return mapInto(_l, f, d - 1, _cb);
      };
      return async.map(l, _into, cb);
    }
  };

  descendObj = function(_obj, _expr, ctx, final_cb) {
    var cb, expr, fn1, i, len, map_get, obj, ref, set, step, tasks;
    if (_obj == null) {
      return final_cb(null, void 0);
    }
    obj = _.clone(_obj);
    expr = _.clone(_expr);
    step = expr.shift();
    if (DEBUG) {
      console.log("\n/ - - ~ @ ~ - - \\");
      inspect(obj);
      console.log("      == @ ==> ");
      inspect(step);
      console.log("\\ - - ~ @ ~ - - /\n");
    }
    if (expr.length === 0) {
      cb = final_cb;
    } else {
      cb = function(err, ret) {
        return descendObj(ret, expr, ctx, final_cb);
      };
    }
    if (step == null) {
      cb(null, obj);
    }
    if (step.map != null) {
      map_get = function(__obj, _cb) {
        return descendObj(__obj, [
          {
            get: step.map
          }
        ], ctx, _cb);
      };
      return mapInto(obj, map_get, step.depth, cb);
    } else if (step.sub != null) {
      return runPipelines(step.sub, obj, ctx, cb);
    } else if (_.isArray(step.get)) {
      tasks = step.get.map(function(step_expr) {
        return function(_cb) {
          return descendObj(obj, step_expr, ctx, _cb);
        };
      });
      return async.parallel(tasks, cb);
    } else if (_.isObject(step.get) && (step.get.obj != null)) {
      tasks = [];
      ref = step.get.obj;
      fn1 = function(set) {
        var e, k;
        k = set.key;
        e = set.val;
        if (_.isString(k)) {
          return tasks.push(function(_cb) {
            return descendObj(obj, e, ctx, function(err, v_obj) {
              var dobj;
              dobj = {
                key: k,
                val: v_obj
              };
              return _cb(null, dobj);
            });
          });
        } else {
          return tasks.push(function(_cb) {
            return descendObj(obj, k, ctx, function(err, k_obj) {
              return descendObj(obj, e, ctx, function(err, v_obj) {
                var dobj;
                dobj = {
                  key: k_obj,
                  val: v_obj
                };
                return _cb(null, dobj);
              });
            });
          });
        }
      };
      for (i = 0, len = ref.length; i < len; i++) {
        set = ref[i];
        fn1(set);
      }
      return async.parallel(tasks, function(err, results) {
        var j, len1, result, result_obj;
        result_obj = {};
        for (j = 0, len1 = results.length; j < len1; j++) {
          result = results[j];
          result_obj[result.key] = result.val;
        }
        return cb(null, result_obj);
      });
    } else {
      return cb(null, accessor(obj, step.get));
    }
  };

  accessor = function(obj, key) {
    if (key === '.') {
      return obj;
    } else {
      if (key.match(/^-?\d+/)) {
        key = Number(key);
        if (key < 0) {
          return obj.slice(key)[0];
        }
      }
      return obj[key];
    }
  };

  through = function(cmd) {
    return function(inp, args, ctx, cb) {
      var pipeline, ref;
      pipeline = parsePipelines(cmd)[0];
      if (pipeline[0].cmd != null) {
        (ref = pipeline[0].cmd).push.apply(ref, args);
      }
      return runPipeline(pipeline, inp, ctx, cb);
    };
  };

  at = function(inp, expr, ctx, cb) {
    return descendObj(inp, expr, ctx, cb);
  };

  module.exports = {
    Pipeline: Pipeline,
    Context: Context,
    parsePipelines: parsePipelines,
    runPipeline: runPipeline,
    doCmd: doCmd,
    through: through,
    at: at
  };

}).call(this);
